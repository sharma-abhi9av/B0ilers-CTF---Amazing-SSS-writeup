
# b01lersCTF — “Amazing SSS” Write‑Up

> Sometimes the simplest mistakes make for the best puzzles.

---

## Why I Picked This One

I saw **“Amazing SSS”** in the CTF menu and thought, “Shamir’s Secret Sharing—classic crypto puzzle.” Once I poked around, I realized the creator had accidentally handed us the secret on a silver platter: every share revealed the secret mod its prime. That little oversight turned into a fun CRT exercise, so I figured I’d share how I cracked it.

---

## What You Need

- **OS:** Any Linux (I used Kali)
- **Python:** 3.8+ (I tested on 3.10)
- **Library:** `pycryptodome`
- **Tool:** `ncat` (for SSL connections)

```bash
pip install pycryptodome
```

---

## The Challenge in a Nutshell

When you connect:

```bash
$ ncat --ssl asss.atreides.b01lersc.tf 8443
Here is a ^_^: 16032943035835318567
Here is your share ^_^: (18141388941280970179, 312789142013581770945...)
```

- The server sends you a 64‑bit prime ``.
- You get a share `(x, y)` generated by a polynomial that—surprise!—collapses mod `a` so that `y % a = secret % a`.

### The Big Idea

Because every share gives `s mod a`, you just collect enough different primes `a_i` until the product covers all \~528 bits of the secret. Then a quick Chinese Remainder Theorem (CRT) run stitches the pieces back into the original integer, which you convert to bytes for the flag.

---

## What the Server Code Shows (ASSS.py)

After grabbing a share live, I grabbed the `ASSS.py` source from the challenge. It laid out exactly how shares were made:

```python
from Crypto.Util.number import getPrime, bytes_to_long

def evaluate_poly(poly:list, x:int, s:int):
    return s + sum(co*x**(i+1) for i, co in enumerate(poly))

s = bytes_to_long(open("./flag.txt", "rb").read())
a = getPrime(64)
# Coefficients are each a random 64-bit prime multiplied by 'a'
poly = [a*getPrime(64) for _ in range(1, 20)]
share = getPrime(64)

print(f"Here is a ^_^: {a}")
print(f"Here is your share ^_^: ({share}, {evaluate_poly(poly, share, s)})")
```

Key takeaways:
- The secret `s` is the integer form of the flag (read from `flag.txt`).
- A fresh 64-bit prime `a` is chosen each connection.
- The polynomial is built as `f(x) = s + (a·c₁)x + (a·c₂)x² + …` where each `cᵢ` is itself a random 64-bit prime.
- Because every coefficient except `s` is a multiple of `a`, `f(x) % a == s % a`.

---

## Step 1: Grab One Share

```python
import socket, ssl, re

def get_share():
    ctx = ssl.create_default_context()
    with socket.create_connection(("asss.atreides.b01lersc.tf", 8443)) as sock:
        ssock = ctx.wrap_socket(sock, server_hostname="asss.atreides.b01lersc.tf")
        data = ssock.recv(4096).decode()

    a = int(re.search(r"Here is a \^_\^: (\d+)", data).group(1))
    y = int(re.search(r"\(\d+,\s*(\d+)\)", data).group(1))
    return a, y
```

This connects over SSL, reads the lines, and pulls out `a` and `y` with regular expressions.

---

## Step 2: Collect Enough of Them

```python
from math import prod

moduli = []
remainders = []
TARGET_BITS = 66 * 8  # 528 bits

while prod(moduli).bit_length() <= TARGET_BITS:
    a, y = get_share()
    moduli.append(a)
    remainders.append(y % a)
    print(f"Collected prime #{len(moduli)}: total bits ≈ {prod(moduli).bit_length()}")
```

We keep going until the product of all our primes is at least 2⁵²⁸, which guarantees our recovered number covers the full secret range.

---

## Step 3: CRT to the Rescue

```python
from math import prod

def crt(remainders, moduli):
    M = prod(moduli)
    x = 0
    for r, m in zip(remainders, moduli):
        Mi = M // m
        inv = pow(Mi, -1, m)
        x += r * Mi * inv
    return x % M
```

This is the classic way to solve a system of congruences in \(O(n)\) time.

---

## Step 4: All Together Now

```python
from Crypto.Util.number import long_to_bytes

if __name__ == '__main__':
    # 1) grab shares until we're confident we've covered 528 bits
    moduli, remainders = [], []
    while prod(moduli).bit_length() <= TARGET_BITS:
        a, y = get_share()
        moduli.append(a)
        remainders.append(y % a)

    # 2) run CRT to reconstruct the secret integer
    secret_int = crt(remainders, moduli)

    # 3) turn it into bytes and print the flag
    flag = long_to_bytes(secret_int).decode()
    print("\nHere’s the flag:\n", flag)
```

---

## What It Looked Like When I Ran It

```
Collected prime #1: total bits ≈ 64
Collected prime #2: total bits ≈ 127
... up to prime #9: total bits ≈ 594

Here’s the flag:
 bctf{shamir_secret_sharing_isn't_ass_but_this_implementation_isXD}
```

---

## Lessons Learned

1. **Don’t shortcut SSS**: Always pick random coefficients in \(\mathbb{Z}_p\).
2. **Enforce thresholds**: If you want a t‑of‑n scheme, don’t let each share leak anything useful by itself.
3. **Rate limiting**: Prevent users from grinding for unlimited shares.

That’s it! Hope you enjoyed this walk‑through—feel free to drop me a message if anything’s unclear. Good luck on the rest of the CTF!

